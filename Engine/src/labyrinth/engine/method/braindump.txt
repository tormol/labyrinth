declare variable
	.varname

	
de-nest version:
all variables are stored in one array
every function has a range of cells that it uses to store named and temporary variables.
why not just a normal stack? dont know where non-local variables are


.eqsupplier =( :par
	:	.val
		=(par)
		:a b
		:	==
			(a val)
		;
	;)
.a =(eqsupplier(5))
.b =(eqsupplier(6))
a(5 4)
becomes
cells
1	:==
2	:=
100		eqsupplier
101	:f1
102		par
103		val
104	:f2
105		anon.a
106		anon.b
107		a
108	5
109		b
110	6
111	4

super manage 100 
	load 100
	call 2 101
	load 107
	call 100 108
	call 2 107
	load 109
	call 100 110
	call 2 109
	call 107 ...uses a list of integers to find that 5 is also in 108... 108  111
		...check parameters
		...set cell 105 and 106
		
	
f1	...push 102 103
	...check parameters
	...set cell 102 to paramater 1	# 0 is a struct
	load 103
	call 2 102
	load 104
	...pop 102 103
f2	...push 105 106
	...check parameters
	...set cell 105 to parameter 1
	...set cell 106 to parameter 2
	call 1 105 103
	
	...pop 105 106
or something like that, uses many cells and many very small objects, following that path you end up with valid assembly,, and should use jni to run it
the apparent issue of non-local variables could be solved by using new cells every time a function is declared to store non-local variables


function instance
every time a function is declared, a new instance is created
an instance is a type with a function and a list of references


a not-so low and simple appropach: calls capture the previous statement as what to call, and the parameter is statements. this way normal function calls are a single statement, and can be used as parameters.
by